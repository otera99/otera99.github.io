<html>

<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-41JZ6X4N12"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-41JZ6X4N12');
</script>

<script>
MathJax = {
    tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
};
</script>
<script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<title>Tatsuya Terao</title>
<link href="css/style.css" rel="stylesheet" media="all">
</head>

<style>

.openbox input {
    display: none; 
}
.openbox .boxshow {
    height: 0;
    opacity: 0; 
    display: none;
}
.inputcss:checked + .boxshow {
    height: auto;
    opacity: 1; 
    display: block;
    font-size: 14px;
}
.openbox label {
    display: inline-block;
    background: #ffe4b5;
    border-radius: 7px 7px 7px 7px;
    padding: 2px 5px;
    cursor: pointer;
    font-size: 14px;
}

body {
  font-family: 'Comic Sans MS', 'Comic Sans';
}
</style>


<body bgcolor="#FFFFFF">

<h2><strong>Tatsuya Terao (<font face="Osaka">寺尾 樹哉</font>)</strong>
</h2>

<p><font size="4">
    Email: ttatsuya [ at ] kurims.kyoto-u.ac.jp</font></p>
 <p align="left"><a href="index_ja.html"><font size="5">[Japanese page]</font></a></p>

<hr>

<p>I am Tatsuya Terao, a first-year doctoral student in <a href="https://www.kurims.kyoto-u.ac.jp/coss/index-e.html">Discrete Optimization Group</a> at <a href="https://www.kurims.kyoto-u.ac.jp/en/index.html">Research Institute for Mathematical Sciences</a> and I am fortunate to be advised by <a href="https://www.kurims.kyoto-u.ac.jp/~yusuke/eindex.html">Yusuke Kobayashi</a>.
I have a interest in the design and analysis of algorithms in theoretical computer science.

<hr>

<h4>CV</h4>

<ul>
    <li>March 2024, Master of Science, Kyoto University</li>
    <li>March 2022, Bachelor of Science, Kyoto University</li>
</ul>

<ul>
    <li>April 2024 - March 2027, Research Fellow of the Japan Society for the Promotion of Science (DC1)</li>
</ul>

<p><a href="CV_Tatsuya_Terao.pdf"><font size="4">[CV in PDF format]</font></a></p>

<h3 id="publications">Publications
</h3>

<p>See <a href="https://dblp.org/pid/335/5620.html">DBLP</a> for a more up-to-date list.</p>

<p>As is the convention in theoretical computer science, authors are listed alphabetically. Exceptions are marked with &dagger;.</p>

<h5>Refereed Papers</h5>

<ol>
    <li>
        <strong>Parameterized Quantum Query Algorithms for Graph Problems</strong> &dagger; [<a href="https://arxiv.org/abs/2408.03864">arXiv</a>, <a href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol308-esa2024/LIPIcs.ESA.2024.99/LIPIcs.ESA.2024.99.pdf">proceeding</a>, <a href="eslide/2024.09.04.ESA.pdf">slides@ESA</a>] <br />
        Tatsuya Terao, <a href="https://q.c.titech.ac.jp/mori/">Ryuhei Mori</a> <br />
        Proceedings of the 32nd Annual European Symposium on Algorithms (<strong>ESA 2024</strong>) <br />
        <div class="openbox">
        <label for="esa2024">▼ Abstract</label>
        <input id="esa2024" class="inputcss" type="checkbox" />
        <span class="boxshow">
            <div class="box6">
                In this paper, we consider the parameterized quantum query complexity for graph problems. We design parameterized quantum query algorithms for $k$-vertex cover and $k$-matching problems, and present lower bounds on the parameterized quantum query complexity. Then, we show that our quantum query algorithms are optimal up to a constant factor when the parameters are small. Our main results are as follows. <br/>
                
                <b>Parameterized quantum query complexity of vertex cover.</b>
                In the $k$-vertex cover problem, we are given an undirected graph $G$ with $n$ vertices and an integer $k$, and the objective is to determine whether $G$ has a vertex cover of size at most $k$. We show that the quantum query complexity of the $k$-vertex cover problem is $O(\sqrt{k}n + k^{3/2}\sqrt{n})$ in the adjacency matrix model. For the design of the quantum query algorithm, we use the method of kernelization, a well-known tool for the design of parameterized classical algorithms, combined with Grover's search. <br/>
                
                <b>Parameterized quantum query complexity of matching.</b>
                In the $k$-matching problem, we are given an undirected graph $G$ with $n$ vertices and an integer $k$, and the objective is to determine whether $G$ has a matching of size at least $k$. We show that the quantum query complexity of the $k$-matching problem is $O(\sqrt{k}n + k^{2})$ in the adjacency matrix model. We obtain this upper bound by using Grover's search carefully and analyzing the number of Grover's searches by making use of potential functions. We also show that the quantum query complexity of the maximum matching problem is $O(\sqrt{p}n + p^{2})$ where $p$ is the size of the maximum matching. For small $p$, it improves known bounds $\tilde{O}(n^{3/2})$ for bipartite graphs [Blikstad--v.d.Brand--Efron--Mukhopadhyay--Nanongkai, FOCS 2022] and $O(n^{7/4})$ for general graphs [Kimmel--Witter, WADS 2021]. <br/>
                
                <b>Lower bounds on parameterized quantum query complexity.</b>
                We also present lower bounds on the quantum query complexities of the $k$-vertex cover and $k$-matching problems. The lower bounds prove the optimality of the above parameterized quantum query algorithms up to a constant factor when $k$ is small. Indeed, the quantum query complexities of the $k$-vertex cover and $k$-matching problems are both $\Theta(\sqrt{k} n)$ when $k = O(\sqrt{n})$ and $k = O(n^{2/3})$, respectively.
                
            </div>
        </span>
        </div>
    </li>

    <li>
        <strong>Subquadratic Submodular Maximization with a General Matroid Constraint</strong> [<a href="https://arxiv.org/abs/2405.00359">arXiv</a>, <a href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol297-icalp2024/LIPIcs.ICALP.2024.100/LIPIcs.ICALP.2024.100.pdf">proceeding</a>, <a href="eslide/2024.07.09.ICALP.pdf">slides@ICALP</a>]<br />
        <a href="https://www.kurims.kyoto-u.ac.jp/~yusuke/eindex.html">Yusuke Kobayashi</a>, Tatsuya Terao <br />
        Proceedings of the 51st EATCS International Colloquium on Automata, Languages and Programming (<strong>ICALP 2024</strong>) <br />
        <div class="openbox">
        <label for="icalp2024">▼ Abstract</label>
        <input id="icalp2024" class="inputcss" type="checkbox" />
        <span class="boxshow">
            <div class="box6">
                We consider fast algorithms for monotone submodular maximization with a general matroid constraint. We present a randomized $(1 - 1/e - \varepsilon)$-approximation algorithm that requires $\tilde{O}_{\varepsilon}(\sqrt{r} n)$ independence oracle and value oracle queries, where $n$ is the number of elements in the matroid and $r \leq n$ is the rank of the matroid. This improves upon the previously best algorithm by Buchbinder-Feldman-Schwartz [Mathematics of Operations Research 2017] that requires $\tilde{O}_{\varepsilon}(r^2 + \sqrt{r}n)$ queries.  <br />

                Our algorithm is based on continuous relaxation, as with other submodular maximization algorithms in the literature. To achieve subquadratic query complexity, we develop a new rounding algorithm, which is our main technical contribution. The rounding algorithm takes as input a point represented as a convex combination of $t$ bases of a matroid and rounds it to an integral solution. Our rounding algorithm requires $\tilde{O}(r^{3/2} t)$ independence oracle queries, while the previously best rounding algorithm by Chekuri-Vondr&aacute;k-Zenklusen [FOCS 2010] requires $O(r^2 t)$ independence oracle queries. A key idea in our rounding algorithm is to use a directed cycle of arbitrary length in an auxiliary graph, while the algorithm of Chekuri-Vondr&aacute;k-Zenklusen focused on directed cycles of length two. 
            </div>
        </span>
        </div>
    </li>

    <li>
        <strong>Faster Matroid Partition Algorithms</strong> [<a href="https://dl.acm.org/doi/10.1145/3707208">journal</a>, <a href="https://arxiv.org/abs/2303.05920">arXiv</a>, <a href="https://drops.dagstuhl.de/opus/volltexte/2023/18156/pdf/LIPIcs-ICALP-2023-104.pdf">proceeding</a>, <a href="eslide/2023.07.14.ICALP.pdf">slides@ICALP</a>]<br />
        Tatsuya Terao <br />
        ACM Transactions on Algorithms (<strong>TALG</strong>), 2025 <br />
        A preliminary version appeared in Proceedings of the 50th EATCS International Colloquium on Automata, Languages and Programming (<strong>ICALP 2023</strong>) <br />
        <div class="openbox">
        <label for="icalp2023">▼ Abstract</label>
        <input id="icalp2023" class="inputcss" type="checkbox" />
        <span class="boxshow">
            <div class="box6">
                In the matroid partitioning problem, we are given $k$ matroids $\mathcal{M}_1 = (V, \mathcal{I}_1), \dots , \mathcal{M}_k = (V, \mathcal{I}_k)$ defined over a common ground set $V$ of $n$ elements, and we need to find a partitionable set $S \subseteq V$ of largest possible cardinality, denoted by $p$. Here, a set $S \subseteq V$ is called partitionable  if there exists a partition $(S_1, \dots , S_k)$ of $S$ with $S_i \in \mathcal{I}_i$ for $i = 1, \ldots, k$. In 1986, Cunningham~[SICOMP 1986] presented a matroid partition algorithm that uses $O(n p^{3/2} + k n)$ independence oracle queries, which was the previously known best algorithm. This query complexity is $O(n^{5/2})$ when $k \leq n$. <br />

                Our main result is to present a matroid partition algorithm that uses $\tilde{O}(k'^{1/3} n p + k n)$ independence oracle queries, where $k' = \min\{k, p\}$. This query complexity is $\tilde{O}(n^{7/3})$ when $k \leq n$, which improves upon that of Cunningham's algorithm. To obtain our algorithm, we present a new approach <i>edge recycling augmentation</i>, which can be attained through new ideas: an efficient utilization of the binary search technique by Nguy$\tilde{{\hat{\text{e}}}}$n~[2019] and Chakrabarty-Lee-Sidford-Singla-Wong~[FOCS 2019] and a careful analysis of the independence oracle query complexity. Our analysis differs significantly from the one for matroid intersection algorithms, because of the parameter $k$. We also present a matroid partition algorithm that uses $\tilde{O}((n + k) \sqrt{p})$ rank oracle queries.
            </div>
        </span>
        </div>
    </li>

    <li>
        <strong>One-Face Shortest Disjoint Paths with a Deviation Terminal</strong> [<a href="https://drops.dagstuhl.de/opus/volltexte/2022/17332/pdf/LIPIcs-ISAAC-2022-47.pdf">proceeding</a>, <a href="eslide/2022.12.20.ISAAC.pdf">slides@ISAAC</a>]<br />
        <a href="https://www.kurims.kyoto-u.ac.jp/~yusuke/eindex.html">Yusuke Kobayashi</a>, Tatsuya Terao <br />
        Proceedings of the 33rd International Symposium on Algorithms and Computation (<strong>ISAAC 2022</strong>) <br />
        <div class="openbox">
            <label for="isaac2022">▼ Abstract</label>
            <input id="isaac2022" class="inputcss" type="checkbox" />
            <span class="boxshow">
                <div class="box6">
                    For an undirected graph $G$ and distinct vertices $s_1, t_1, \dots, s_k, t_k$ called terminals, 
                    the shortest $k$-disjoint paths problem asks for $k$ pairwise vertex-disjoint paths $P_1, \dots , P_k$ 
                    such that $P_i$ connects $s_i$ and $t_i$ for $i = 1, \dots , k$ and the sum of their lengths is minimized.
                    This problem is a natural optimization version of the well-known $k$-disjoint paths problem, 
                    and its polynomial solvability is widely open. 
                    One of the best results on the shortest $k$-disjoint paths problem is due to Datta et al. [FSTTCS 2018], 
                    who present a polynomial-time algorithm for the case when $G$ is planar and all the terminals are on one face. 
                    In this paper, we extend this result by giving a polynomial-time randomized algorithm for the case when 
                    all the terminals except one are on some face of $G$. 
                    In our algorithm, we combine the arguments of Datta et al.~with some results on the shortest disjoint $(A + B)$-paths problem shown by Hirai and Namba [Algorithmica 2018]. 
                    To this end, we present a non-trivial bijection between $k$ disjoint paths and disjoint $(A + B)$-paths, which is a key technical contribution of this paper.
                </div>
            </span>
            </div>
    </li>
</ol>

<h5>Manuscripts</h5>
<ol>
    <li>
        <strong>Deterministic $(2/3 - \varepsilon)$-Approximation of Matroid Intersection using Nearly-Linear Independence-Oracle Queries</strong> [<a href="https://arxiv.org/abs/2410.18820">arXiv</a>]<br />
        Tatsuya Terao <br />
        <div class="openbox">
            <label for="deterministic2024">▼ Abstract</label>
            <input id="deterministic2024" class="inputcss" type="checkbox" />
            <span class="boxshow">
                <div class="box6">
                    In the matroid intersection problem, we are given two matroids $\mathcal{M}_1 = (V, \mathcal{I}_1)$ and $\mathcal{M}_2 = (V, \mathcal{I}_2)$ defined on the same ground set $V$ of $n$ elements, and the objective is to find a common independent set $S \in \mathcal{I}_1 \cap \mathcal{I}_2$ of largest possible cardinality, denoted by $r$. In this paper, we consider a deterministic matroid intersection algorithm with only a nearly linear number of independence oracle queries. Our contribution is to present a deterministic $O(\frac{n}{\varepsilon} + r \log r)$-independence-query $(2/3-\varepsilon)$-approximation algorithm for any $\varepsilon > 0$. Our idea is very simple: we apply a recent $\tilde{O}(n \sqrt{r}/\varepsilon)$-independence-query $(1 - \varepsilon)$-approximation algorithm of Blikstad [ICALP 2021], but terminate it before completion. Moreover, we also present a semi-streaming algorithm for $(2/3 -\varepsilon)$-approximation of matroid intersection in $O(1/\varepsilon)$ passes.
                </div>
            </span>
            </div>
    </li>
</ol>

<hr>
</body>
</html>
